#include <time.h>
#include "SDL.h"
#include "renderer.h"
#include "assets.h"
#include "common.h"

typedef struct {
	Coord origin;
	Sprite sprite;
	double speed;
} Planet;

typedef struct {
	char map[10][20];							//Vertical rectangle (width / 2, height + 1/3)
	Coord origin;
	Sprite sprite;
} Platform;

static Sprite spaceSprite;
static SDL_Texture *tileMap;
static const double SCROLL_SPEED = 0.5;			//TODO: Should be in FPS.
double bgOffset;
static Planet planets[5];

static long lastPlanetTime;
static double nextPlanetSpawnSeconds;
static int PLANET_SPAWN_MIN_SECONDS = 5;
static int PLANET_SPAWN_MAX_SECONDS = 15;
static int planetInc;
static int PLANET_SPEED_MIN = 6;				//will /10
static int PLANET_SPEED_MAX = 8;
static int planetLimit;
static int PLANET_BOUND = 32;

static long lastPlatformTime;
static double nextPlatformSpawnSeconds;
static int PLATFORM_SPAWN_MIN_SECONDS = 1;
static int PLATFORM_SPAWN_MAX_SECONDS = 5;
static double PLATFORM_SCROLL_SPEED = 0.7;
const int PLATFORM_SCALE = 2;
static Platform platforms[20];
static int platformInc;
static int platformLimit;
static Sprite baseSprite;
static SDL_Texture* platformCanvas;

static const int PLATFORM_SEED_X = 3;
static const int PLATFORM_SEED_Y = 6;
static const int PLATFORM_SEED_DENSITY = 75;
static bool seedMap[3][6];

static bool isNullPlanet(Planet* planet) {
	return planet->speed == 0;
}

SDL_Texture* createPlatformTexture() {
	return SDL_CreateTexture(
		renderer,
		SDL_PIXELFORMAT_RGBA8888,
		SDL_TEXTUREACCESS_TARGET,
		(int)PLATFORM_SEED_X * PLATFORM_SCALE * 16,
		(int)PLATFORM_SEED_Y * PLATFORM_SCALE * 16
	);
}

void makePlatformCanvas() {
	//Create an initial 'seed map' to base eventual platform appearance on. This can scale based on a constant.
	// (taking care to set false cases, since these aren't automatically set).
	for(int x=0; x < PLATFORM_SEED_X; x++){
		for(int y=0; y < PLATFORM_SEED_Y; y++) {
			seedMap[x][y] = chance(PLATFORM_SEED_DENSITY);
		}
	}

	//Create tile map canvas texture.
	SDL_Texture* canvas = createPlatformTexture();

	//Change renderer context to output onto the tilemap.
	SDL_SetRenderTarget(renderer, canvas);

	//Make transparent (initially)
	SDL_SetTextureBlendMode(canvas, SDL_BLENDMODE_BLEND);
	SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_NONE);
	SDL_SetRenderDrawColor(renderer, 0, 0, 0, 0);
	SDL_RenderFillRect(renderer, NULL);

	//Restore renderer context back to the window canvas.
	SDL_SetRenderTarget(renderer, NULL);

	platformCanvas = canvas;
}

void initBackground() {
	makePlatformCanvas();

	//We render out the tile map to a big texture, that we blit onto the screen on each frame.
	// This saves a lot of processing time drawing out individual tiles on each frame.
	//Note that we render out to a 1:1 ratio (i.e. smaller than the actual screen, then scale
	// this up via the renderScale factor, so we only need a small physical image in memory, i.e.
	// scaling is done when applying the texture.

	planetLimit = sizeof(planets) / sizeof(Planet);
	platformLimit = sizeof(platforms) / sizeof(Platform);

	//Load the spaceTexture
	SDL_Texture *spaceTexture = getTexture("space.png");
	spaceSprite = makeSprite(spaceTexture, zeroCoord(), SDL_FLIP_NONE);

	//We want to scale the sprite_t up to our pixel grid.
	Coord tileSize = makeCoord(
		spaceSprite.size.x,
		spaceSprite.size.y
	);

	//Create tile map canvas texture.
	tileMap = SDL_CreateTexture(
		renderer,
		SDL_PIXELFORMAT_UNKNOWN,
		SDL_TEXTUREACCESS_TARGET,
		(int)pixelGrid.x, (int)pixelGrid.y
	);

	//Change renderer context to output onto the tilemap.
	SDL_SetRenderTarget(renderer, tileMap);

	//Replicate the tile across the screen area.
	for(int x=0; x < pixelGrid.x; x += tileSize.x){
		for(int y=0; y < pixelGrid.y; y += tileSize.y) {
			SDL_Rect destination  = {
				x, y,
				(int)tileSize.x, (int)tileSize.y
			};

			SDL_RenderCopy(renderer, spaceSprite.texture, NULL, &destination);
		}
	}

	//Restore renderer context back to the window canvas.
	SDL_SetRenderTarget(renderer, NULL);
}

void backgroundRenderFrame() {
	//We show two large textures, one after the other, to create a seamless scroll. Once the first texture
	// moves out of the viewport, however, we snap it back to the top.

	//Blit out our first texture
	SDL_Rect destination  = {
		0, (int)bgOffset,
		(int)windowSize.x, (int)windowSize.y
	};
	SDL_RenderCopy(renderer, tileMap, NULL, &destination);

	//Blit out our second texture, offset by the first texture accordingly.
	SDL_Rect destination2 = {
		0, (int)bgOffset - (int)windowSize.y,
		(int)windowSize.x, (int)windowSize.y
	};
	SDL_RenderCopy(renderer, tileMap, NULL, &destination2);

	//Render planets.
	for(int i=0; i < planetLimit; i++) {
		//Skip null planets.
		if(isNullPlanet(&planets[i])) continue;
		drawSpriteAbs(planets[i].sprite, planets[i].origin);
	}

	//Draw base.
	for(int i=0; i < platformLimit; i++) {
		//Skip null platforms.
		if(platforms[i].origin.x == 0) continue;

		drawSpriteAbs(platforms[i].sprite, platforms[i].origin);
	}
}

Platform makePlatform(Coord origin) {
	Platform p;
	p.origin = origin;

	//Local variables.
	Coord tileSize = makeCoord(16, 16);

	//Make texture and copy blank canvas onto it.
	SDL_Texture* tileMap = createPlatformTexture();
	SDL_SetRenderTarget(renderer, tileMap);

	SDL_RenderCopy(renderer, platformCanvas, NULL, NULL);
	SDL_SetTextureBlendMode(tileMap, SDL_BLENDMODE_BLEND);
	SDL_RenderFillRect(renderer, NULL);

	//Get base asset.
	SDL_Texture *baseTexture = getTexture("base.png");
	baseSprite = makeSprite(baseTexture, zeroCoord(), SDL_FLIP_NONE);

	//TODO: Randomly-blended (128 alpha) tiles to give depth look.

	//Replicate the tile across the screen area, operating on seed map to scale.
	int xTile = 0;
	for(double x=0; x < PLATFORM_SEED_X * PLATFORM_SCALE; x += 1 / (double)PLATFORM_SCALE, xTile += tileSize.x){
		int yTile = 0;
		for(double y=0; y < PLATFORM_SEED_Y * PLATFORM_SCALE; y += 1 / (double)PLATFORM_SCALE, yTile += tileSize.y) {
			if(!seedMap[(int)floor(x)][(int)floor(y)]) continue;
			SDL_Rect destination  = {
				xTile, yTile,
				(int)tileSize.x, (int)tileSize.y
			};

			SDL_RenderCopy(renderer, baseSprite.texture, NULL, &destination);
		}
	}

	//Restore renderer context back to the window canvas.
	SDL_SetRenderTarget(renderer, NULL);

	p.sprite = makeSprite(tileMap, zeroCoord(), SDL_FLIP_NONE);

	return p;
}

void backgroundGameFrame() {
	//Chunk the textures downwards on each frame, or reset if outside view.
	bgOffset = bgOffset > windowSize.y ? 0 : bgOffset + SCROLL_SPEED;

	//Spawn planets.
	if(isDueInSeconds(&lastPlanetTime, nextPlanetSpawnSeconds)) {
		if(planetInc == planetLimit) planetInc = 0;

		//Choose random planet type.
		char planetFile[50];
		int randPlanet = random(1, 4);
		sprintf(planetFile, "planet-%02d.png", randPlanet);

		SDL_Texture *planetTexture = getTexture(planetFile);
		Sprite planetSprite = makeSprite(planetTexture, zeroCoord(), SDL_FLIP_NONE);

		Planet planet = {
			makeCoord(random(0, (int)screenBounds.x), -PLANET_BOUND),
			planetSprite,
			(random(PLANET_SPEED_MIN, PLANET_SPEED_MAX)) * 0.1
		};
		planets[planetInc++] = planet;

		//Spawn next planet at a random time.
		nextPlanetSpawnSeconds = random(PLANET_SPAWN_MIN_SECONDS, PLANET_SPAWN_MAX_SECONDS);
	}

	//Scroll planets.
	for(int i=0; i < planetLimit; i++) {
		planets[i].origin.y += planets[i].speed;
	}

	if(isDueInSeconds(&lastPlatformTime, nextPlatformSpawnSeconds)) {
		if(platformInc == platformLimit) platformInc = 0;

		//TODO: Algorithm to remove free-floating, or otherwise corner-hinged tiles from platform geometry.
		//TODO: Decorate borders with edge sprites.

		Coord origin = makeCoord(random(0, (int)screenBounds.x), 0);
		Platform platform = makePlatform(origin);
		platforms[platformInc++] = platform;

		//Spawn next planet at a random time.
		nextPlatformSpawnSeconds = random(PLATFORM_SPAWN_MIN_SECONDS, PLATFORM_SPAWN_MAX_SECONDS);
	}
	
	//Scroll planets.
	for(int i=0; i < platformLimit; i++) {
		platforms[i].origin.y += PLATFORM_SCROLL_SPEED;
	}
}
